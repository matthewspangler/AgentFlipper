"""
Processes user requests and interacts with the Flipper Zero and LLM agents.
"""

import logging
from typing import Optional, List, Tuple

from colors import Colors
from hardware_manager import FlipperZeroManager
from llm_agent import LLMAgent

logger = logging.getLogger("FlipperAgent")

def process_user_request(user_input: str, flipper_agent: FlipperZeroManager, llm_agent: LLMAgent, recursion_depth: int = 0):
    """
    Process a user request and execute any tool calls.

    Args:
        user_input: The user's input text
        flipper_agent: The agent that communicates with Flipper Zero
        llm_agent: The agent that generates tool calls using LLM
        recursion_depth: Current recursion depth for follow-up tool calls

    Returns:
        None
    """
    # Guard against excessive recursion
    if recursion_depth >= llm_agent.max_recursion_depth:
        logger.warning(f"Maximum recursion depth reached ({llm_agent.max_recursion_depth}), stopping chain")
        print(f"\n{Colors.FAIL}Maximum loop depth reached ({llm_agent.max_recursion_depth}). Please issue a new command to continue.{Colors.ENDC}")
        # Generate a final summary when we stop due to recursion limit
        summary = llm_agent.generate_summary()
        print(f"\n{Colors.CYAN}Final Summary:{Colors.ENDC}")
        print(f"{summary}\n")
        return

    # Generate summary every 3 iterations to keep context fresh
    if recursion_depth > 0 and recursion_depth % 3 == 0:
        summary = llm_agent.generate_summary()
        print(f"\n{Colors.CYAN}Progress Summary:{Colors.ENDC}")
        print(f"{summary}\n")

    # Get tool calls from LLM
    tool_calls = llm_agent.get_commands(user_input)

    # Handle empty response
    if not tool_calls:
        logger.warning("No tool calls were generated by the LLM")
        print(f"\n{Colors.WARNING}No response was generated. Try rephrasing your request.{Colors.ENDC}")
        return

    # Process each tool call
    for call in tool_calls:
        name = call["name"]
        args = call["arguments"]

        if name == "execute_commands":
            commands = args["commands"]
            # Execute commands and get results
            print(f"{Colors.GREEN}{'─' * 50}{Colors.ENDC}")
            print(f"{Colors.PURPLE}Executing {len(commands)} commands...{Colors.ENDC}")
            for i, cmd in enumerate(commands, 1):
                print(f"{Colors.BOLD}{i}.{Colors.ENDC} {cmd}")
            print(f"{Colors.GREEN}{'─' * 50}{Colors.ENDC}")
            results = flipper_agent.execute_commands(commands)

            # Check for command errors
            command_failed = False
            for cmd, resp in results:
                if "error" in resp.lower() or "illegal" in resp.lower():
                    command_failed = True
                    break

            # Add results to conversation history for better summaries
            llm_agent.add_execution_results_to_history(results)

            # If command failed, provide error information
            if command_failed:
                error_info = "Command execution failed. Please check the device response."
                print(f"{Colors.FAIL}{'─' * 50}{Colors.ENDC}")
                print(f"{Colors.FAIL}# Error:{Colors.ENDC}")
                print(f"{Colors.BOLD}{error_info}{Colors.ENDC}")
                print(f"{Colors.FAIL}{'─' * 50}{Colors.ENDC}")

        elif name == "provide_information":
            information = args["information"]
            # Display information to user
            print(f"{Colors.GREEN}{'─' * 50}{Colors.ENDC}")
            print(f"{Colors.GREEN}# Information:{Colors.ENDC}")
            print(f"{Colors.BOLD}{information}{Colors.ENDC}")
            print(f"{Colors.GREEN}{'─' * 50}{Colors.ENDC}")

        elif name == "ask_question":
            question = args["question"]
            # Ask user question
            print(f"{Colors.BLUE}{'─' * 50}{Colors.ENDC}")
            print(f"{Colors.BLUE}? {question}{Colors.ENDC}")
            print(f"{Colors.BLUE}{'─' * 50}{Colors.ENDC}")
            return  # Pause execution for user input

        elif name == "mark_task_complete":
            # Mark task as complete
            print(f"{Colors.GREEN}{'─' * 50}{Colors.ENDC}")
            print(f"{Colors.GREEN}✓ Task completed {Colors.ENDC}")
            print(f"{Colors.GREEN}{'─' * 50}{Colors.ENDC}")
            llm_agent.task_in_progress = False
            llm_agent.task_description = ""
            return True  # Indicate task completion

    # If we get here, we processed all tool calls without completing the task or asking a question
    # Check if we executed any commands - if so, force task completion to prevent infinite loops
    command_executed = any(call["name"] == "execute_commands" for call in tool_calls)
    task_completed = any(call["name"] == "mark_task_complete" for call in tool_calls)

    if command_executed and not task_completed and recursion_depth > 0:
        print(f"\n{Colors.ORANGE}Command executed but task not marked complete. Forcing completion to prevent loop.{Colors.ENDC}")
        llm_agent.task_in_progress = False
        llm_agent.task_description = ""
        return True

    # Continue the loop if under recursion limit
    if recursion_depth < llm_agent.max_recursion_depth:
        print(f"\n{Colors.PURPLE}Continuing task...{Colors.ENDC}")
        process_user_request(user_input, flipper_agent, llm_agent, recursion_depth + 1)